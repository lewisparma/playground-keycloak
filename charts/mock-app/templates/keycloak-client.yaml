{{- if .Values.keycloak.enabled -}}
apiVersion: keycloak.org/v1alpha1
kind: KeycloakClient
metadata:
  name: {{ include "webapp.fullname" . }}-mock-web-client
{{- with .Values.keycloak.namespace }}
  namespace: {{ . }}
{{- end }}
  labels:
    {{- include "webapp.labels" . | nindent 4 }}
spec:
  realmSelector:
    matchLabels:
      {{- toYaml .Values.keycloak.realmLabels | nindent 6 }}
  client:
    clientId: {{ include "webapp.clientId" . }}
    protocol: openid-connect
{{/* TODO: ("https:" or "http:" + $host.host) prefix, if $host.host given */}}
    redirectUris:
{{- with $ingress := .Values.ingress }}
  {{- range $path := $ingress.paths }}
    {{- range $host := $ingress.hostnames }}
      - {{ $path }}callback/
    {{- end }}
  {{- end }}
{{- end }}
    implicitFlowEnabled: true
    standardFlowEnabled: true
    serviceAccountsEnabled: true
    directAccessGrantsEnabled: true
    # TODO: set up a secret that we can know
    # i) adding 'secret: string' here sets the literal string as the secret
    #    -- but only when creating the Client; operator never updates it
    #    if the Client already exists.  So if we use some randStr, it changes
    #    on redeploy, and goes out of sync.
    # ii) letting the operator generate a secret, and fish it out of the
    #     keycloak-client-secret-${clientId} Secret.  Mounting said Secret
    #     doesn't work cross-namespace (which is the desired way to deploy apps)
{{- end -}}
